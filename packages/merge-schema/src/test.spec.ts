import { mergeTypes } from './index';

describe('mergeTypes', () => {
  it('should merge types', () => {
    const types = [`type Test {id: ID}`, `type Test2 {id: ID}`];
    expect(mergeTypes(types)).toEqual(
      [
        `schema {`,
        `  query: Query`,
        `}`,
        ``,
        `type Query`,
        ``,
        `type Test {`,
        `  id: ID`,
        `}`,
        ``,
        `type Test2 {`,
        `  id: ID`,
        `}`,
        ``,
      ].join('\n'),
    );
  });
  it('should work orderBy directive', () => {
    const types = [`type Test {id: ID}`, `type Test2 {tests: [Test] @orderBy}`];
    expect(mergeTypes(types)).toEqual(
      [
        `schema {`,
        `  query: Query`,
        `}`,
        ``,
        `type Query`,
        ``,
        `enum OrderDirection {`,
        `  ASC`,
        `  DESC`,
        `}`,
        ``,

        `type Test {`,
        `  id: ID`,
        `}`,
        ``,
        `type Test2 {`,
        `  tests(orderBy: [TestOrder]): [Test]`,
        `}`,
        ``,
        `type TestOrder {`,
        `  sort: TestSort`,
        `  direction: OrderDirection`,
        `}`,
        ``,
        `enum TestSort {`,
        `  ID`,
        `}`,
        ``,
      ].join('\n'),
    );
  });
  it('should work where directive', () => {
    const types = [`type Test {id: ID}`, `type Test2 {tests: [Test] @where }`];
    expect(mergeTypes(types)).toEqual(
      [
        `schema {`,
        `  query: Query`,
        `}`,
        ``,
        `type Query`,
        ``,
        `type IDWhereOperator {`,
        `  type: IDWhereOperatorType!`,
        `  value: [ID]!`,
        `}`,
        ``,
        `enum IDWhereOperatorType {`,
        `  EQ`,
        `  NOT_EQ`,
        `  IN`,
        `  NOT_IN`,
        `}`,
        ``,

        `type Test {`,
        `  id: ID`,
        `}`,
        ``,
        `type Test2 {`,
        `  tests(where: TestWhere): [Test]`,
        `}`,
        ``,
        `type TestWhere {`,
        `  id: [IDWhereOperator]`,
        `}`,
        ``,
      ].join('\n'),
    );
  });
  it('should work relay directive', () => {
    const types = [`type Test {id: ID}`, `type Test2 {tests: [Test] @relay }`];
    expect(mergeTypes(types)).toEqual(
      [
        `schema {`,
        `  query: Query`,
        `}`,
        ``,
        `type Query`,
        ``,
        `interface Connection {`,
        `  totalCount: Int`,
        `  pageInfo: PageInfo!`,
        `  edges: [Edge]`,
        `}`,
        ``,
        `interface Edge {`,
        `  cursor: String`,
        `}`,
        ``,
        `interface Node {`,
        `  id: ID!`,
        `}`,
        ``,
        `type PageInfo {`,
        `  startCursor: String`,
        `  endCursor: String`,
        `  hasNextPage: Boolean`,
        `  hasPreviousPage: Boolean`,
        `}`,
        ``,
        `type Test implements Node {`,
        `  id: ID`,
        `}`,
        ``,
        `type Test2 {`,
        `  tests(before: String, after: String, first: Int, last: Int): TestConnection`,
        `}`,
        ``,
        `type TestConnection implements Connection {`,
        `  totalCount: Int`,
        `  edges: [TestEdge]`,
        `  pageInfo: PageInfo!`,
        `}`,
        ``,
        `type TestEdge implements Edge {`,
        `  node: Test`,
        `  cursor: String`,
        `}`,
        ``,
      ].join('\n'),
    );
  });
  it('should work orderBy, where, and relay directive', () => {
    const types = [
      `type Test {id: ID}`,
      `type Test2 {tests: [Test] @orderBy @where @relay }`,
    ];
    expect(mergeTypes(types)).toEqual(
      [
        `schema {`,
        `  query: Query`,
        `}`,
        ``,
        `type Query`,
        ``,
        `interface Connection {`,
        `  totalCount: Int`,
        `  pageInfo: PageInfo!`,
        `  edges: [Edge]`,
        `}`,
        ``,
        `interface Edge {`,
        `  cursor: String`,
        `}`,
        ``,
        `type IDWhereOperator {`,
        `  type: IDWhereOperatorType!`,
        `  value: [ID]!`,
        `}`,
        ``,
        `enum IDWhereOperatorType {`,
        `  EQ`,
        `  NOT_EQ`,
        `  IN`,
        `  NOT_IN`,
        `}`,
        ``,
        `interface Node {`,
        `  id: ID!`,
        `}`,
        ``,
        `enum OrderDirection {`,
        `  ASC`,
        `  DESC`,
        `}`,
        ``,
        `type PageInfo {`,
        `  startCursor: String`,
        `  endCursor: String`,
        `  hasNextPage: Boolean`,
        `  hasPreviousPage: Boolean`,
        `}`,
        ``,

        `type Test implements Node {`,
        `  id: ID`,
        `}`,
        ``,
        `type Test2 {`,
        `  tests(orderBy: [TestOrder], where: TestWhere, before: String, after: String, first: Int, last: Int): TestConnection`,
        `}`,
        ``,
        `type TestConnection implements Connection {`,
        `  totalCount: Int`,
        `  edges: [TestEdge]`,
        `  pageInfo: PageInfo!`,
        `}`,
        ``,
        `type TestEdge implements Edge {`,
        `  node: Test`,
        `  cursor: String`,
        `}`,
        ``,
        `type TestOrder {`,
        `  sort: TestSort`,
        `  direction: OrderDirection`,
        `}`,
        ``,
        `enum TestSort {`,
        `  ID`,
        `}`,
        ``,
        `type TestWhere {`,
        `  id: [IDWhereOperator]`,
        `}`,
        ``,
      ].join('\n'),
    );
  });
});
